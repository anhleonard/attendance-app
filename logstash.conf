input {
  beats {
    port => 5044
  }
}

filter {
  # Parse full log line with temporary field names
  grok {
    match => { 
      "message" => [
        # Primary pattern - with JSON payload and query string
        "%{TIMESTAMP_ISO8601:temp_timestamp} \[%{LOGLEVEL:temp_level}\] \[(?<temp_request_id>[^\]]+)\] %{WORD:temp_method} (?<temp_url>[^\?]+)\?(?<temp_query_params>[^ ]+) - %{NUMBER:temp_status} \(%{NUMBER:temp_time}ms\) \| %{GREEDYDATA:temp_json}",
        # Without query string but with JSON
        "%{TIMESTAMP_ISO8601:temp_timestamp} \[%{LOGLEVEL:temp_level}\] \[(?<temp_request_id>[^\]]+)\] %{WORD:temp_method} %{URIPATHPARAM:temp_url} - %{NUMBER:temp_status} \(%{NUMBER:temp_time}ms\) \| %{GREEDYDATA:temp_json}",
        # With query string, no JSON
        "%{TIMESTAMP_ISO8601:temp_timestamp} \[%{LOGLEVEL:temp_level}\] \[(?<temp_request_id>[^\]]+)\] %{WORD:temp_method} (?<temp_url>[^\?]+)\?(?<temp_query_params>[^ ]+) - %{NUMBER:temp_status} \(%{NUMBER:temp_time}ms\)",
        # Minimal pattern - no JSON, no query
        "%{TIMESTAMP_ISO8601:temp_timestamp} \[%{LOGLEVEL:temp_level}\] \[(?<temp_request_id>[^\]]+)\] %{WORD:temp_method} %{URIPATHPARAM:temp_url} - %{NUMBER:temp_status} \(%{NUMBER:temp_time}ms\)"
      ]
    }
    tag_on_failure => ["_grokparsefailure"]
  }

  # Only process further if grok parsing was successful
  if "_grokparsefailure" not in [tags] {

    # Rename temporary fields to final field names
    mutate {
      rename => {
        "temp_timestamp" => "log_timestamp"
        "temp_level" => "log_level"
        "temp_request_id" => "request_id"
        "temp_method" => "request_method"
        "temp_url" => "request_url"
        "temp_status" => "response_status"
        "temp_time" => "response_time"
        "temp_json" => "json_payload"
        "temp_query_params" => "query_params"
      }
    }

    # Handle query params - add to URL if present
    if [query_params] {
      mutate {
        add_field => { "request_url" => "%{request_url}?%{query_params}" }
        remove_field => ["query_params"]
      }
    }

    # Parse JSON payload - only if json_payload field exists
    if [json_payload] {
      json {
        source => "json_payload"
        target => "parsed"
        tag_on_failure => ["_jsonparsefailure"]
      }
      
      # Remove json_payload after parsing
      mutate {
        remove_field => ["json_payload"]
      }
    }

    # Parse timestamp - support both with and without milliseconds
    if [log_timestamp] {
      date {
        match => [ 
          "log_timestamp", 
          "yyyy-MM-dd HH:mm:ss.SSS",
          "yyyy-MM-dd HH:mm:ss",
          "ISO8601"
        ]
        target => "@timestamp"
        tag_on_failure => ["_dateparsefailure"]
      }
      
      # Remove after successful parsing
      mutate {
        remove_field => ["log_timestamp"]
      }
    }

    # Convert response_status and response_time to integers
    if [response_status] {
      mutate {
        convert => { "response_status" => "integer" }
      }
    }

    if [response_time] {
      mutate {
        convert => { "response_time" => "integer" }
      }
    }

    # Add metadata
    mutate {
      add_field => { 
        "service" => "learning-app"
      }
    }

    # Add status category for easy filtering
    if [response_status] {
      if [response_status] >= 500 {
        mutate { add_field => { "status_category" => "server_error" } }
      } else if [response_status] >= 400 {
        mutate { add_field => { "status_category" => "client_error" } }
      } else if [response_status] >= 300 {
        mutate { add_field => { "status_category" => "redirect" } }
      } else if [response_status] >= 200 {
        mutate { add_field => { "status_category" => "success" } }
      }
    }
  }
}

output {
  # Debug output - ENABLE THIS TO SEE PARSED DATA
  stdout { 
    codec => rubydebug {
      metadata => true
    }
  }

  # Successfully parsed logs
  if "_grokparsefailure" not in [tags] {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      data_stream => true
      data_stream_type => "logs"
      data_stream_dataset => "app"
      data_stream_namespace => "default"
    }
  }

  # Failed logs - send to separate index for debugging
  if "_grokparsefailure" in [tags] {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "failed-logs-%{+YYYY.MM.dd}"
    }
  }
}
